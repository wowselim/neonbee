plugins {
    // core plugins
    id 'java'
    id 'application'
    id 'eclipse'
    id 'maven-publish' // mandatory plugin, to publish on Nexus with dependencies. the plugin needs the configuration block "publishing" (see publishing.gradle)
    id 'jacoco'
    id 'pmd'
    id 'checkstyle'

    // community plugins
    id 'com.palantir.docker' version '0.31.0'
    id 'com.diffplug.spotless' version '6.0.5'
    id 'net.ltgt.errorprone' version '2.0.2'
    id 'com.github.spotbugs' version '5.0.3'
    id 'org.ajoberstar.grgit' version '4.1.1'
    id 'com.github.ksoichiro.console.reporter' version '0.6.3'
    id 'se.bjurr.violations.violations-gradle-plugin' version '1.50.16'
    id 'com.github.johnrengelman.shadow' version '7.1.0'
    id 'org.sonarqube' version '3.3'
    id 'team.yi.semantic-gitlog' version '0.5.17'
}

group = 'io.neonbee'
version = '0.17.1-SNAPSHOT'
mainClassName = 'io.neonbee.Launcher'
archivesBaseName = 'neonbee-core'
sourceCompatibility = 11

project.ext {
    isReleaseVersion = !version.endsWith('-SNAPSHOT')
    distributionDir = file("${buildDir}/dist")
    distributionLibsDir = file("${distributionDir}/libs")
    generatedTrustStorePassword = UUID.randomUUID().toString()
}

repositories {
    mavenCentral()
}

// we need to define the generated source set first, because it is needed by staticCodeCheck
sourceSets {
    generated {
        java {
            srcDir 'src/generated/java'
        }
    }
}

apply from: 'gradle/dependencies.gradle'
apply from: 'gradle/distribution.gradle'
apply from: 'gradle/publishing.gradle'
apply from: 'gradle/codeCoverage.gradle'
apply from: 'gradle/release.gradle'
apply from: 'gradle/staticCodeCheck.gradle'
apply from: 'gradle/changelog.gradle'

task initWrapper(type: Wrapper) {
    gradleVersion = '7.2'
}

// ############ Annotation Processing

task annotationProcessing(type: JavaCompile, group: 'build') {
    options.annotationProcessorPath = configurations.annotationProcessor

    inputs.dir 'src/main/java'
    outputs.dir 'src/generated/java'

    source = sourceSets.main.java
    classpath = configurations.compileClasspath
    destinationDirectory = project.file('src/generated/java')
    options.compilerArgs = [
        "-proc:only",
        "-processor", "io.vertx.codegen.CodeGenProcessor"
    ]
}

// please note that due to this import the whole annotation processing cannot be split off to an own script
// plugin (apply from: ...) due to we must use the JavaExtension on the classpath loaded by the above plugin block.
// re-importing it in the script plugin, even with a own buildscript block, will not work, trust me! ;)

import com.diffplug.gradle.spotless.JavaExtension
import com.diffplug.spotless.LineEnding
def spotlessGeneratedExtension = new JavaExtension(spotless)
spotlessGeneratedExtension.target sourceSets.generated.java.srcDirs
spotlessGeneratedExtension.encoding 'UTF8'
spotlessGeneratedExtension.trimTrailingWhitespace()
spotlessGeneratedExtension.removeUnusedImports()
spotlessGeneratedExtension.endWithNewline()
spotlessGeneratedExtension.setLineEndings(LineEnding.UNIX)
spotlessGeneratedExtension.importOrderFile("${rootDir}/gradle/spotless/neonbee.importorder")
spotlessGeneratedExtension.eclipse('4.17.0').configFile "${rootDir}/gradle/spotless/eclipse-formatter.xml"
spotlessGeneratedExtension.custom 'Lambda fix', { it.replace('} )', '})').replace('} ,', '},') }

def spotlessApplyGenerated = spotlessGeneratedExtension.createIndependentApplyTask('spotlessApplyGenerated')
spotlessApplyGenerated.mustRunAfter('annotationProcessing')
spotlessApplyGeneratedHelper.mustRunAfter('annotationProcessing')

task generateCode {
    dependsOn annotationProcessing
    dependsOn spotlessApplyGenerated
}

compileJava {
    dependsOn generateCode
    source += sourceSets.generated.java
    options.compilerArgs += '-proc:none'
}

compileGeneratedJava {
    // This task will be automatically executed when calling "gradlew build", but the generated sources were already
    // build in the customized "compileJava" task. Therefore there is no need to compile the classes again.
    // This compiliation would also produce compiling issues, because this classpath doesn't contian all dependencies.
    source = []
}

clean {
    delete += sourceSets.generated.java.srcDirs
}

// ############ Test Phase

test {
    // Is required for ReflectionsHelper
    jvmArgs += ['--add-opens', 'java.base/java.lang.reflect=ALL-UNNAMED']

    if (!org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.getCurrentOperatingSystem().isMacOsX()) {
        systemProperties = [
            'junit.jupiter.execution.parallel.enabled' : 'true',
            'junit.jupiter.execution.parallel.mode.default' : 'concurrent',
            'junit.jupiter.execution.parallel.mode.classes.default' : 'concurrent'
        ]
    }

    environment 'vertx.parameter.filename', file('src/test/resources/vertx-parameters.json').absolutePath

    // Later, if the violations plugin supports JUNIT5 we have to ignore the issues
    // during SpotBugs run, because the violations plugin will display the issues
    // and let the build fail later. But currently we have to fail directly.
    ignoreFailures = false
    dependsOn('spotlessCheck', 'cleanTest')
    useJUnitPlatform()
    testLogging {
        events = ['passed', 'skipped', 'failed', 'standardOut', 'standardError']
        exceptionFormat = org.gradle.api.tasks.testing.logging.TestExceptionFormat.FULL // Full display of exceptions
        // Don't show complete standard out and standard error of the tests on the console.
        // Show only verbose output for failing tests.
        showStandardStreams = false
    }
    reports {
        junitXml {
            required = true
            destination = file("${buildDir}/reports/junit/xml")
        }
        html {
            required = true
            destination = file("${buildDir}/reports/junit/html")
        }
    }
    finalizedBy jacocoTestReport
}

// ############ Docker Build

docker {
    dependsOn distTar

    def dockerName = archivesBaseName+':'
    name dockerName+'latest'
    tag 'version', dockerName+version
    tag 'majorVersion', dockerName+version.split('\\.')[0]
    tag 'minorVersion', dockerName+version.substring(0, version.lastIndexOf('.'))
    files tasks.distTar.outputs
    buildArgs([NEONBEE_VERSION: version])
    pull true
}

// ############ SonarQube Plugin

sonarqube {
    properties {
        property 'sonar.sourceEncoding', 'UTF-8'
        property "sonar.projectKey", "neonbee_key"
        property "sonar.organization", "neonbee"
        property "sonar.host.url", "https://sonarcloud.io"
        property 'sonar.coverage.jacoco.xmlReportPaths', "${buildDir}/reports/jacoco/xml/jacoco.xml"
        property 'sonar.junit.reportPaths', "${buildDir}/reports/junit/xml"
    }
}

// ############ Violations Plugin

task violations(type: se.bjurr.violations.gradle.plugin.ViolationsTask) {
    maxReporterColumnWidth = 10 // 0 means "no limit"
    maxRuleColumnWidth = 50
    maxSeverityColumnWidth = 10
    maxLineColumnWidth = 10
    maxMessageColumnWidth = 200
    minSeverity = 'INFO' // INFO, WARN or ERROR
    detailLevel = 'VERBOSE' // PER_FILE_COMPACT, COMPACT or VERBOSE
    maxViolations = 0 // Fail the build if total number of found violations is higher
    printViolations = true

    // Formats are listed here: https://github.com/tomasbjerre/violations-lib
    violations = [
        ['FINDBUGS', buildDir.path, ".*/build/reports/spotbugs/.*\\.xml\$",'Spotbugs'],
        ['JUNIT', buildDir.path, ".*/build/reports/junit/xml/.*\\.xml\$",'JUnit'],
        ['PMD', buildDir.path, ".*/build/reports/pmd/.*\\.xml\$", 'PMD'],
        ['CHECKSTYLE', buildDir.path, ".*/build/reports/checkstyle/.*\\.xml\$", 'Checkstyle']
    ]
}
check.finalizedBy violations
test.finalizedBy violations
build.finalizedBy violations

// ############ JavaDoc Build

javadoc {
    if(JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption('html5', true)
    }
}

import org.gradle.internal.logging.events.OutputEvent
import org.gradle.internal.logging.events.OutputEventListener
import org.gradle.internal.logging.LoggingOutputInternal
tasks.withType(Javadoc) {
    def exceptions = []
    doFirst {
        gradle.services.get(LoggingOutputInternal).addOutputEventListener(new OutputEventListener() {
            void onOutput(OutputEvent event) {
                String eventString = event.toString()
                if (eventString =~ " warning: ") {
                    if (eventString =~ " warning: no comment") {
                        // Ignore warnings if a class is missing a JavaDoc,
                        // therefore we have checkstyle
                        // With Java 18 we can also suppress this warnings in the console
                        // https://bugs.openjdk.java.net/browse/JDK-8189591
                    } else {
                        exceptions << "Javadoc warning: ${event.toString()}"
                    }
                }
            }
        })
    }
    doLast {
         if (exceptions.size() > 0) {
            throw new GradleException(String.join('\n', exceptions))
        }
    }
}

// ############ Release

task release(type: Exec) {
    workingDir projectDir
    if (project.hasProperty('nextVersion')) {
        def nextVersion = project.getProperty('nextVersion')
        println 'Releasing next version ' + nextVersion
        if (System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
            commandLine 'cmd', '/c', 'gradle/release.sh', nextVersion
        } else {
            commandLine 'sh', '-c', "./gradle/release.sh ${nextVersion}"
        }
    }
}
